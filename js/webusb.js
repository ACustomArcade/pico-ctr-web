/**
 * PicoCTR WebUSB Communication Layer
 *
 * Handles USB communication with PicoCTR devices via the WebUSB browser API
 * using the vendor bulk JSON protocol. All commands and responses are
 * length-prefixed JSON messages over bulk endpoints.
 *
 * Protocol reference: .github/settings-api.md in the firmware repository.
 * Config data (output types, button codes, etc.) loaded from picoctr-config.json
 * (generated by tools/generate_web_config.py from firmware annotations).
 */

class PicoCTRDevice {
    constructor(config) {
        this.config = config;
        this.device = null;
        this.interfaceNumber = -1;
        this.epOut = null;
        this.epIn = null;
        this._onDisconnect = null;
        this._disconnectHandler = null;
        this._cmdQueue = Promise.resolve(); // serialize bulk commands
    }

    /** Check if WebUSB is available in this browser */
    static isSupported() {
        return !!navigator.usb;
    }

    /** Get whether a device is currently connected and opened */
    get connected() {
        return this.device !== null && this.device.opened;
    }

    /**
     * Parse a hex string like "0x1075" to an integer.
     * If already a number, return as-is.
     */
    _hex(val) {
        if (typeof val === 'number') return val;
        return parseInt(val, 16);
    }

    /**
     * Build WebUSB filters from config.
     * Filters by VID/PID pairs to target PicoCTR devices.
     */
    _buildFilters() {
        return this.config.transport.filters.map(f => ({
            vendorId: this._hex(f.vendorId),
            productId: this._hex(f.productId),
        }));
    }

    /**
     * Request and open a PicoCTR device via WebUSB.
     * Finds the vendor bulk interface and claims it.
     */
    async connect() {
        if (!PicoCTRDevice.isSupported()) {
            throw new Error('WebUSB is not supported in this browser');
        }

        const filters = this._buildFilters();
        this.device = await navigator.usb.requestDevice({ filters });

        await this.device.open();

        // Select configuration 1 if not already selected
        if (this.device.configuration === null) {
            await this.device.selectConfiguration(1);
        }

        // Find the vendor interface (class 0xFF with bulk endpoints)
        const vendorClass = this.config.transport.vendor_class || 0xFF;
        let vendorIface = null;
        for (const iface of this.device.configuration.interfaces) {
            for (const alt of iface.alternates) {
                if (alt.interfaceClass === vendorClass) {
                    const hasBulkOut = alt.endpoints.some(ep => ep.direction === 'out' && ep.type === 'bulk');
                    const hasBulkIn = alt.endpoints.some(ep => ep.direction === 'in' && ep.type === 'bulk');
                    if (hasBulkOut && hasBulkIn) {
                        vendorIface = iface;
                        break;
                    }
                }
            }
            if (vendorIface) break;
        }

        if (!vendorIface) {
            throw new Error('Vendor bulk interface not found — is this a PicoCTR device with firmware v2.0+?');
        }

        this.interfaceNumber = vendorIface.interfaceNumber;
        await this.device.claimInterface(this.interfaceNumber);

        // Find bulk endpoints
        const alternate = vendorIface.alternates[0];
        this.epOut = alternate.endpoints.find(ep => ep.direction === 'out' && ep.type === 'bulk');
        this.epIn = alternate.endpoints.find(ep => ep.direction === 'in' && ep.type === 'bulk');

        if (!this.epOut || !this.epIn) {
            throw new Error('Bulk endpoints not found on vendor interface');
        }

        // Listen for disconnect
        this._disconnectHandler = (event) => {
            if (event.device === this.device) {
                this.device = null;
                this.interfaceNumber = -1;
                this.epOut = null;
                this.epIn = null;
                if (this._onDisconnect) {
                    this._onDisconnect();
                }
            }
        };
        navigator.usb.addEventListener('disconnect', this._disconnectHandler);

        return {
            vendorId: this.device.vendorId,
            productId: this.device.productId,
            productName: this.device.productName,
        };
    }

    /**
     * Set a callback for when the device disconnects.
     */
    onDisconnect(callback) {
        this._onDisconnect = callback;
    }

    /**
     * Close the device connection.
     */
    async disconnect() {
        if (this._disconnectHandler) {
            navigator.usb.removeEventListener('disconnect', this._disconnectHandler);
            this._disconnectHandler = null;
        }
        if (this.device && this.device.opened) {
            try {
                await this.device.releaseInterface(this.interfaceNumber);
            } catch (_) { /* ignore */ }
            try {
                await this.device.close();
            } catch (_) { /* ignore */ }
        }
        this.device = null;
        this.interfaceNumber = -1;
        this.epOut = null;
        this.epIn = null;
    }

    // ========================================================================
    // Wire Protocol
    // ========================================================================

    /**
     * Send a JSON command and receive the JSON response.
     * Handles length-prefix framing: [uint16 LE length][JSON payload]
     */
    async sendCommand(command) {
        if (!this.connected) throw new Error('Not connected');

        // Serialize all commands through a queue to prevent interleaved
        // bulk IN/OUT transfers on the shared endpoint pair.
        let resolve;
        const prev = this._cmdQueue;
        this._cmdQueue = new Promise(r => { resolve = r; });
        await prev;

        try {
            return await this._sendCommandRaw(command);
        } finally {
            resolve();
        }
    }

    async _sendCommandRaw(command) {
        // Encode the JSON payload
        const json = JSON.stringify(command);
        const payload = new TextEncoder().encode(json);

        if (payload.length > 1023) {
            throw new Error(`Command too large: ${payload.length} bytes (max 1023)`);
        }

        // Build framed message: [uint16 LE length][JSON bytes]
        const frame = new Uint8Array(2 + payload.length);
        frame[0] = payload.length & 0xFF;
        frame[1] = (payload.length >> 8) & 0xFF;
        frame.set(payload, 2);

        // Send via bulk OUT
        await this.device.transferOut(this.epOut.endpointNumber, frame);

        // Read response — may arrive in multiple USB packets
        // First collect the 2-byte length header
        let headerData = new Uint8Array(0);
        while (headerData.length < 2) {
            const result = await this.device.transferIn(this.epIn.endpointNumber, 1024);
            const chunk = new Uint8Array(result.data.buffer);
            const merged = new Uint8Array(headerData.length + chunk.length);
            merged.set(headerData);
            merged.set(chunk, headerData.length);
            headerData = merged;
        }

        const responseLen = headerData[0] | (headerData[1] << 8);

        // Collect the full payload (may already have some from the header read)
        let responseData = headerData.slice(2);
        while (responseData.length < responseLen) {
            const result = await this.device.transferIn(this.epIn.endpointNumber, 1024);
            const chunk = new Uint8Array(result.data.buffer);
            const merged = new Uint8Array(responseData.length + chunk.length);
            merged.set(responseData);
            merged.set(chunk, responseData.length);
            responseData = merged;
        }

        const responseJson = new TextDecoder().decode(responseData.slice(0, responseLen));
        const response = JSON.parse(responseJson);

        if (response.ok === false) {
            throw new Error(response.error || `Command '${command.cmd}' failed`);
        }

        return response;
    }

    // ========================================================================
    // Device Info
    // ========================================================================

    /**
     * Get device identity and capabilities.
     * Returns: { version, version_full, build_type, board, num_gamepads, num_expanders, pins_per_expander }
     */
    async getInfo() {
        return this.sendCommand({ cmd: 'get_info' });
    }

    /**
     * Get all device info at once (convenience wrapper matching old API shape).
     */
    async getDeviceInfo() {
        const info = await this.getInfo();
        return {
            version: info.version || '',
            versionFull: info.version_full || '',
            buildType: info.build_type || '',
            board: info.board || '',
            variant: info.variant || '',
            numGamepads: info.num_gamepads || 0,
            numExpanders: info.num_expanders || 4,
            pinsPerExpander: info.pins_per_expander || 16,
        };
    }

    // ========================================================================
    // Settings Read/Write
    // ========================================================================

    /**
     * Read current in-memory RGB/LED settings.
     * Returns: { enable_rgb, rgb_animation, rgb_r, rgb_g, rgb_b, led_count, led_brightness }
     */
    async getSettings() {
        return this.sendCommand({ cmd: 'get_settings' });
    }

    /**
     * Read flash-persisted settings (for detecting unsaved changes).
     */
    async getFlashSettings() {
        return this.sendCommand({ cmd: 'get_flash_settings' });
    }

    /**
     * Apply settings to device (live preview, not saved to flash).
     * Only include fields you want to change.
     */
    async setSettings(settings) {
        return this.sendCommand({ cmd: 'set_settings', ...settings });
    }

    /**
     * Check if current settings differ from flash (unsaved changes).
     */
    async hasUnsavedChanges() {
        try {
            const [current, flash] = await Promise.all([
                this.getSettings(),
                this.getFlashSettings(),
            ]);
            // Compare the settings fields only
            const fields = ['enable_rgb', 'rgb_animation', 'rgb_r', 'rgb_g', 'rgb_b', 'led_count', 'led_brightness'];
            return fields.some(f => current[f] !== flash[f]);
        } catch {
            return false;
        }
    }

    // ========================================================================
    // Pin Mapping
    // ========================================================================

    /**
     * Get pin mappings for one expander (16 pins).
     * Returns: { expander, pins: [{ t, tg, c }, ...] }
     */
    async getPinMap(expander) {
        return this.sendCommand({ cmd: 'get_pin_map', expander });
    }

    /**
     * Set pin mappings for one expander (16 pins).
     * pins: [{ t, tg, c }, ...] (16 entries)
     */
    async setPinMap(expander, pins) {
        return this.sendCommand({ cmd: 'set_pin_map', expander, pins });
    }

    /**
     * Get physical pin labels for one expander (16 labels).
     * Returns: { expander, labels: [string, ...] }
     */
    async getLabels(expander) {
        return this.sendCommand({ cmd: 'get_labels', expander });
    }

    /**
     * Load all expander data (pin maps + labels) in parallel.
     * Returns array of { index, active, pins: [{ output_type, output_target, output_code, label }, ...] }
     */
    async loadAllExpanders(numExpanders = 4) {
        const expanders = [];
        for (let exp = 0; exp < numExpanders; exp++) {
            // Commands must be serialized — they share the same bulk endpoint
            const pinMap = await this.getPinMap(exp);
            const labels = await this.getLabels(exp);

            const pins = pinMap.pins || [];
            const lbls = labels.labels || [];
            const hasActivePins = pins.some(p => p.t !== 0);

            expanders.push({
                index: exp,
                active: hasActivePins,
                pins: pins.map((pin, i) => ({
                    output_type: pin.t,
                    output_target: pin.tg,
                    output_code: pin.c,
                    label: lbls[i] || '',
                })),
            });
        }
        return expanders;
    }

    // ========================================================================
    // Commands
    // ========================================================================

    /** Save all current settings to flash. */
    async save() {
        return this.sendCommand({ cmd: 'save' });
    }

    /** Reset all settings to factory defaults (auto-saves). */
    async reset() {
        return this.sendCommand({ cmd: 'reset' });
    }

    /** Reboot the device (discards unsaved changes, device will disconnect!). */
    async reboot() {
        try {
            return await this.sendCommand({ cmd: 'reboot' });
        } catch {
            // Expected: device disconnects before response arrives
            return { ok: true };
        }
    }

    /** Enter BOOTSEL mode for firmware update (device will disconnect!). */
    async enterBootsel() {
        try {
            return await this.sendCommand({ cmd: 'bootsel' });
        } catch {
            // Expected: device disconnects before response arrives
            return { ok: true };
        }
    }

    // ========================================================================
    // Config Helpers
    // ========================================================================

    /**
     * Find device config matching a board name.
     */
    findDeviceConfig(boardName) {
        if (!boardName) return null;
        const bn = boardName.toLowerCase();
        return this.config.devices.find(d =>
            d.board.toLowerCase() === bn ||
            d.target.toLowerCase() === bn
        ) || null;
    }

    /**
     * Get enum options for a named enum (e.g., 'animations').
     */
    getEnumOptions(enumName) {
        return this.config.enums[enumName] || [];
    }

    /**
     * Get pin mapping metadata from config.
     */
    getPinMappingConfig() {
        return this.config.pin_mapping || {};
    }

    /**
     * Check if the device has keyboard HID support by inspecting USB interfaces.
     */
    hasKeyboardSupport() {
        if (!this.device || !this.device.configuration) return false;
        return this.device.configuration.interfaces.some(iface =>
            iface.alternates.some(alt =>
                alt.interfaceClass === 3 && alt.interfaceProtocol === 1
            )
        );
    }

    /**
     * Check if the device has mouse HID support by inspecting USB interfaces.
     */
    hasMouseSupport() {
        if (!this.device || !this.device.configuration) return false;
        return this.device.configuration.interfaces.some(iface =>
            iface.alternates.some(alt =>
                alt.interfaceClass === 3 && alt.interfaceProtocol === 2
            )
        );
    }
}

// Export for use by app.js
window.PicoCTRDevice = PicoCTRDevice;
